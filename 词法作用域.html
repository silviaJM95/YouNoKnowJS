词法作用域

1、作用域：定义为一套规则，用来管理引擎如何在当前作用域 以及 嵌套的自作用域中 根据标识符名称进行变量查找

作用域有两种主要的工作模型：
第一种是：词法作用域
第二种是：动态作用域

2、词法阶段
词法作用域是：定义在词法阶段的作用域。换句话说：词法作用域是在写代码时 将变量和块 写在哪里来决定的

示例：嵌套作用域，有作用域气泡
function foo(a) {
  var b = a * 2;

  function bar(c) {
    console.log(a, b, c)
  }
  bar(b * 3)
}

foo(2); //2, 4, 12

3、查找
对示例的解析：首先从最内部 bar 的作用域气泡开始查找，引擎无法在这里找到 a ,去上一级的 foo 中查找，

作用域查找会在找到第一个匹配的标识符时停止，在多层嵌套的作用域中，可以定义同名的标识符，这叫做 “遮蔽效应”

！！
可以通过 window.a 方式访问到被同名变量所遮蔽的全局变量
但若非全局必拿来那个，被遮蔽，则永远无法访问到

！！！
词法作用域只由函数 “被声明时所处的位置” 决定，与函数在哪里被调用，如何被调用，无关

4、欺骗词法
两种方式：eval() + with()

1)eval()

接受一个字符串作为参数，把字符串动态的插入程序中，好似原本就存在一样

function foo(str, a) {
  eval(str) //欺骗   <===> var b = 3;
  console.log(a, b);
}

var b = 2;

foo('var b = 3', 1); //1, 3

修改了原本的词法作用域

默认情况下，如果 eval(...) 中所执行的代码包含一个或多个声明（无论变量还是函数），就会对 eval() 所处的词法作用域进行修改

但是！！在严格模式下，禁止使用 eval()

示例：
function foo(str) {
  "use strict"
  eval(str)
  console.log(a); //ReferenceError: a is not defined
}

foo('var a = 2;')

2）with()
通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身

function foo(obj) {
  with(obj) {
    a = 2;
  }
}

var o1 = {
  a: 3
}

var o2 = {
  b: 3
}

foo(o1)
console.log(o1.a) //2

foo(o2)
console.log(o2.a) //undefined
console.log(a) //2

解析：传递 o1 给with时，with所声明的作用域是 o1， 而o1中含有同o1.a属性相符的标识符，
但是，当 o2 作为作用域时，其中没有a标识符，同时foo(..)的作用域、全局作用域中都没有，
因此当执行a=2时，自动创建一个全局变量（因为是非严格模式）

with 可以将一个没有或者有多个属性的对象处理为一个 “完全隔离的词法作用域” ，因此，这个对象的属性也会被处理为定义在这个作用域中的词法标识符

！！var声明 不会被限制在这个块的作用域中，而胡思被添加到 with 所处的额函数作用域中

5、性能
性能低下